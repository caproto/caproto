'''
Contains PVGroups representing all fields of EPICS base records
'''
# **NOTE**
# This file is auto-generated.  Please edit the source Jinja templates instead.
# **NOTE**

import logging
import sys

from .server import PVGroup, pvproperty
from .._constants import MAX_ENUM_STRING_SIZE
from .._data import ChannelType
from .._dbr import AlarmSeverity
from . import menus


logger = logging.getLogger(__name__)
records = {}


def _link_parent_attribute(pvprop, parent_attr_name, *, read_only=False,
                           use_setattr=False, default=0):
    'Take a pvproperty and link its getter/putter to a parent attribute'

    @pvprop.getter
    async def getter(self, instance):
        return getattr(self.parent, parent_attr_name, default)

    if not read_only:
        if use_setattr:
            @pvprop.putter
            async def putter(self, instance, value):
                if hasattr(self.parent, parent_attr_name):
                    setattr(self.parent, parent_attr_name, value)

        else:
            @pvprop.putter
            async def putter(self, instance, value):
                kw = {parent_attr_name: value}
                await self.parent.write_metadata(**kw)

    return pvprop


def _link_enum_strings(pvprop, index):
    'Take a pvproperty and link its parent enum_strings[index]'

    @pvprop.getter
    async def getter(self, instance):
        try:
            return self.parent.enum_strings[index]
        except IndexError:
            return ''

    @pvprop.putter
    async def putter(self, instance, value):
        enum_strings = list(self.parent.enum_strings)

        if index >= len(enum_strings):
            missing_count = index - len(enum_strings) + 1
            enum_strings = enum_strings + [''] * missing_count

        old_enum = enum_strings[index]
        enum_strings[index] = str(value)[:MAX_ENUM_STRING_SIZE - 1]

        await self.parent.write_metadata(enum_strings=enum_strings)
        if self.parent.value in (old_enum, index):
            await self.parent.write(value=index)

    return pvprop


def register_record(cls):
    'Register a record type to be used with pvproperty mock_record'
    assert issubclass(cls, PVGroup)
    records[cls._record_type] = cls
    logger.debug('Registered record type %r', cls._record_type)
    return cls


class RecordFieldGroup(PVGroup):
    _scan_rate_sec = None
    _dtype = None  # to be set by subclasses
    has_val_field = True

{% set rec = records['base'] %}
{% include "record_body.jinja2" %}

    # -- Above is auto-generated --

    # Add some handling onto the autogenerated code above:
    record_type = pvproperty(
        name='RTYP', dtype=ChannelType.STRING, read_only=True,
        doc='Record type')

    def __init__(self, prefix, **kw):
        super().__init__(prefix, **kw)

        parent = self.parent
        # set .NAME
        self.record_name._data['value'] = parent.pvname
        # set .RTYP
        self.record_type._data['value'] = self._record_type

        # automatic alarm handling
        self._alarm = parent.alarm
        self._alarm.connect(self)

    async def publish(self, flags):
        # if SubscriptionType.DBE_ALARM in flags:
        # TODO this needs tweaking - proof of concept at the moment
        await self.alarm_acknowledge_transient.write(
            self._alarm.must_acknowledge_transient)
        await self.alarm_acknowledge_severity.write(
            self._alarm.severity_to_acknowledge)
        await self.alarm_status.write(self._alarm.status)
        await self.current_alarm_severity.write(self._alarm.severity)

    # TODO: server single-char issue with caget?

    @scan_rate.putter
    async def scan_rate(self, instance, value):
        scan_string = (self.scan_rate.enum_strings[value]
                       if isinstance(value, int)
                       else value)

        if scan_string in ('I/O Intr', 'Passive', 'Event'):
            self._scan_rate_sec = 0
        else:
            self._scan_rate_sec = float(scan_string.split(' ')[0])

        if hasattr(self.parent, 'scan_rate'):
            self.parent.scan_rate = self._scan_rate_sec

    @property
    def scan_rate_sec(self):
        'Record scan rate, in seconds (read-only)'
        return self._scan_rate_sec

    @process_record.putter
    async def process_record(self, instance, value):
        await self.parent.write(self.parent.value)

    _link_parent_attribute(description, '__doc__', use_setattr=True)


class _Limits(PVGroup):
    high_alarm_limit = pvproperty(
        name='HIGH', dtype=ChannelType.DOUBLE, doc='High Alarm Limit')
    high_severity = pvproperty(
        name='HSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='High Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MINOR_ALARM])
    hihi_alarm_limit = pvproperty(
        name='HIHI', dtype=ChannelType.DOUBLE, doc='Hihi Alarm Limit')
    hihi_severity = pvproperty(
        name='HHSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Hihi Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MAJOR_ALARM])
    lolo_alarm_limit = pvproperty(
        name='LOLO', dtype=ChannelType.DOUBLE, doc='Lolo Alarm Limit')
    lolo_severity = pvproperty(
        name='LLSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Lolo Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MAJOR_ALARM])
    low_alarm_limit = pvproperty(
        name='LOW', dtype=ChannelType.DOUBLE, doc='Low Alarm Limit')
    low_severity = pvproperty(
        name='LSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Low Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MINOR_ALARM])
    high_operating_range = pvproperty(
        name='HOPR', dtype=ChannelType.DOUBLE, doc='High Operating Range')
    low_operating_range = pvproperty(
        name='LOPR', dtype=ChannelType.DOUBLE, doc='Low Operating Range')

    _link_parent_attribute(hihi_alarm_limit, 'upper_alarm_limit')
    _link_parent_attribute(lolo_alarm_limit, 'lower_alarm_limit')

    _link_parent_attribute(high_alarm_limit, 'upper_warning_limit')
    _link_parent_attribute(low_alarm_limit, 'lower_warning_limit')

    _link_parent_attribute(high_operating_range, 'upper_ctrl_limit')
    _link_parent_attribute(low_operating_range, 'lower_ctrl_limit')


class _LimitsLong(PVGroup):
    high_alarm_limit = pvproperty(
        name='HIGH', dtype=ChannelType.LONG, doc='High Alarm Limit')
    high_severity = pvproperty(
        name='HSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='High Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MINOR_ALARM])
    hihi_alarm_limit = pvproperty(
        name='HIHI', dtype=ChannelType.LONG, doc='Hihi Alarm Limit')
    hihi_severity = pvproperty(
        name='HHSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Hihi Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MAJOR_ALARM])
    lolo_alarm_limit = pvproperty(
        name='LOLO', dtype=ChannelType.LONG, doc='Lolo Alarm Limit')
    lolo_severity = pvproperty(
        name='LLSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Lolo Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MAJOR_ALARM])
    low_alarm_limit = pvproperty(
        name='LOW', dtype=ChannelType.LONG, doc='Low Alarm Limit')
    low_severity = pvproperty(
        name='LSV',
        dtype=ChannelType.ENUM,
        enum_strings=menus.menuAlarmSevr.get_string_tuple(),
        doc='Low Severity',
        value=menus.menuAlarmSevr.get_string_tuple()[
            AlarmSeverity.MINOR_ALARM])
    high_operating_range = pvproperty(
        name='HOPR', dtype=ChannelType.LONG, doc='High Operating Range')
    low_operating_range = pvproperty(
        name='LOPR', dtype=ChannelType.LONG, doc='Low Operating Range')

    _link_parent_attribute(hihi_alarm_limit, 'upper_alarm_limit')
    _link_parent_attribute(lolo_alarm_limit, 'lower_alarm_limit')

    _link_parent_attribute(high_alarm_limit, 'upper_warning_limit')
    _link_parent_attribute(low_alarm_limit, 'lower_warning_limit')

    _link_parent_attribute(high_operating_range, 'upper_ctrl_limit')
    _link_parent_attribute(low_operating_range, 'lower_ctrl_limit')


{% for rec in records.values() | sort(attribute='sort_id') %}
{%- if rec.record_type %}
@register_record
class {{ rec.class_name }}({{ rec.base_class }}{% if rec.mixin %}, {{ rec.mixin | join(', ') }}{% endif %}):
    _record_type = {% if rec.record_type %}"{{ rec.record_type }}"{% else %}None{% endif %}

    _dtype = {{ rec.dtype }}  # DTYP of .VAL
{% if rec.dtype %}
    has_val_field = True
{% else %}
    has_val_field = False
{% endif %}
{% include "record_body.jinja2" %}
{% set record_specific_template = 'record_body_' + rec.record_type + '.jinja2' %}
{% include record_specific_template ignore missing %}


{% endif %}
{% endfor %}


def summarize(file=sys.stdout):
    'Summarize all supported records and their fields'
    all_records = [('base', RecordFieldGroup)] + list(records.items())

    def to_string(s):
        if callable(s):
            return 'callable/' + s.__name__
        return repr(s)

    base_fields = {
        pvprop.pvspec.name
        for attr, pvprop in RecordFieldGroup._pvs_.items()
    }

    for record, rclass in all_records:
        info = [record, [cls.__name__ for cls in rclass.mro()]]
        print('\t'.join(to_string(s) for s in info), file=file)
        for attr, pvprop in rclass._pvs_.items():
            if record != 'base' and pvprop.pvspec.name in base_fields:
                continue

            kwargs = (
                f'{key}={value}'.format(key, value)
                for key, value in sorted(pvprop.pvspec.cls_kwargs.items())
            )
            info = [attr] + list(pvprop.pvspec) + list(kwargs)
            print('\t'.join(to_string(s) for s in info), file=file)
        print(file=file)


__all__ = ['records', 'RecordFieldGroup'] + list(records.keys())
